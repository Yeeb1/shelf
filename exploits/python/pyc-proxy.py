#!/usr/bin/env python3

import os
import sys
import ast
import astor
import argparse


def list_script_info(input_script):
    """
    Parse the Python script and list all function definitions
    and whether an `if __name__ == "__main__":` block is present.
    """
    try:
        with open(input_script, "r", encoding="utf-8") as f:
            original_code = f.read()
    except OSError as e:
        print(f"[!] Could not read file: {e}")
        sys.exit(1)

    try:
        tree = ast.parse(original_code)
    except Exception as e:
        print(f"[!] Failed to parse the script: {e}")
        sys.exit(1)

    functions_found = []
    main_block_found = False

    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            functions_found.append(node.name)
        if (
            isinstance(node, ast.If)
            and isinstance(node.test, ast.Compare)
            and isinstance(node.test.left, ast.Name)
            and node.test.left.id == "__name__"
            and isinstance(node.test.ops[0], ast.Eq)
            and isinstance(node.test.comparators[0], ast.Constant)
            and node.test.comparators[0].value == "__main__"
        ):
            main_block_found = True

    if functions_found:
        print("[+] Functions detected:")
        for func in functions_found:
            print(f"    {func}")
    else:
        print("[+] No functions detected in the script.")

    print(f"[+] Main block detected: {'Yes' if main_block_found else 'No'}")


def inject_command(input_script, command, output_script=None):
    """
    Inject a specified command (subprocess.run()) at the start of
    every function and in the `if __name__ == '__main__':` block.
    Also adds an import for `subprocess` if it doesn't already exist.
    """
    try:
        with open(input_script, "r", encoding="utf-8") as f:
            original_code = f.read()
    except OSError as e:
        print(f"[!] Could not read file: {e}")
        sys.exit(1)

    try:
        tree = ast.parse(original_code)
    except Exception as e:
        print(f"[!] Failed to parse the script: {e}")
        sys.exit(1)

    # Check if `subprocess` is already imported
    subprocess_imported = any(
        (
            isinstance(node, ast.Import) and any(alias.name == "subprocess" for alias in node.names)
        )
        or (
            isinstance(node, ast.ImportFrom) and node.module == "subprocess"
        )
        for node in tree.body
    )

    # If not, add an import node for subprocess at the top of the script
    if not subprocess_imported:
        print("[+] 'subprocess' not found. Adding 'import subprocess'.")
        import_node = ast.Import(names=[ast.alias(name="subprocess", asname=None)])
        tree.body.insert(0, import_node)

    # Prepare the AST for injection
    injection_node = ast.parse(f'subprocess.run("{command}", shell=True)').body[0]
    functions_found = []
    main_block_found = False

    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            functions_found.append(node.name)
            node.body.insert(0, injection_node)

        # Detect `if __name__ == "__main__":` block
        if (
            isinstance(node, ast.If)
            and isinstance(node.test, ast.Compare)
            and isinstance(node.test.left, ast.Name)
            and node.test.left.id == "__name__"
            and isinstance(node.test.ops[0], ast.Eq)
            and isinstance(node.test.comparators[0], ast.Constant)
            and node.test.comparators[0].value == "__main__"
        ):
            main_block_found = True
            node.body.insert(0, injection_node)

    # Print info
    if functions_found:
        print(f"[+] Functions detected and injected: {', '.join(functions_found)}")
    else:
        print("[+] No functions detected. Nothing to inject there.")

    print(f"[+] Main block detected: {'Yes' if main_block_found else 'No'}")

    # Convert the modified AST back to source code
    modified_code = astor.to_source(tree)

    if output_script:
        try:
            with open(output_script, "w", encoding="utf-8") as f:
                f.write(modified_code)
            print(f"[+] Modified script saved to {output_script}")
        except OSError as e:
            print(f"[!] Error writing the modified script to file: {e}")
    else:
        print("[+] Modified script output:")
        print(modified_code)


def show_decompilation_help():
    print("""
Decompiling and Recompiling .pyc Files
--------------------------------------

1. Identify the Python version:
   - Each .pyc file contains a magic number that indicates the Python
     version. You can use 'file yourfile.pyc' on Linux, or open it in
     a hex editor to see the magic number.

2. Use an appropriate decompiler:
   - Tools like 'uncompyle6', 'decompyle3', or 'decompyle++' can often
     handle specific versions of Python bytecode.
   - E.g.: `pip install uncompyle6`
   - Then run: `uncompyle6 yourfile.pyc > output.py`
   - Adjust the command if your .pyc is for Python 3.x or Python 2.x
     as needed.

3. Online Services:
   - You can also use online services like https://pylingual.io/
     to upload and decompile your .pyc files if local tools are
     not available.

4. Recompile your .py file into .pyc:
   - Make sure to use the correct python version for the recompile action.
   - Once you have made your changes, you can turn the file back into
     bytecode with:
       python3 -m compileall yourfile.py --invalidation-mode unchecked-hash
   - The resulting .pyc file can be found under __pycache__.
""")


def main():
    parser = argparse.ArgumentParser(
        description="Inject a subprocess command into Python code (particularly handy for .pyc decompiled scripts)."
    )
    subparsers = parser.add_subparsers(dest="subcommand", help="Subcommands")

    # help 
    parser_help = subparsers.add_parser("help", help="Show tips on decompiling and recompiling .pyc files.")

    # list 
    parser_list = subparsers.add_parser(
        "list",
        help="List functions in the script and check if a main block is present."
    )
    parser_list.add_argument("input_script", help="Path to the Python script to analyze.")

    # inject 
    parser_inject = subparsers.add_parser(
        "inject",
        help="Inject the specified command (subprocess.run) into each function and main block."
    )
    parser_inject.add_argument("input_script", help="Path to the Python script to modify.")
    parser_inject.add_argument("command", help="Command to inject (will run via subprocess.run).")
    parser_inject.add_argument(
        "-o", "--output",
        dest="output_script",
        help="Optional path to save the modified script."
    )

    args = parser.parse_args()

    if args.subcommand == "help":
        show_decompilation_help()

    elif args.subcommand == "list":
        if not os.path.exists(args.input_script):
            print(f"[!] File not found: {args.input_script}")
            sys.exit(1)
        list_script_info(args.input_script)

    elif args.subcommand == "inject":
        if not os.path.exists(args.input_script):
            print(f"[!] File not found: {args.input_script}")
            sys.exit(1)
        inject_command(args.input_script, args.command, args.output_script)

    else:
        parser.print_help()


if __name__ == "__main__":
    main()
